# MYSQl

## 致谢

[参考1](https://topjavaer.cn/database/mysql.html)

##

### 数据库的三大范式

* 1NF：原子性
* 2NF：非主属性完全依赖主键
* 3NF：非主属性直接依赖主键，无依赖传递

## 事务

### 四大特性（ACID）

* 原子性
* 一致性
* 隔离性
* 依赖性

### 执行问题 （！！！标题需要优化）

* 脏读
* 不可重复读
* 幻读

### 隔离级别

* Serializable  (串行化)
* Repeatable read (可重复读) \[RR\]
* Read committed (读已提交) \[RC\]
* Read uncommitted (读未提交)

### 一般用什么隔离级别

* 生产环境一般用RC
* RC并发高于RR

## 编码

### utf8和utf8mb4 区别

* utf8 3字节 - 支持部分字符
* utf8 4字节 - 几乎可以表示所有已知字符，包括emoji

### collation

* ci 不区分大小写
* general 挨个对比字符
* unicode 挨个对比unicode
* bin 挨个对比二进位

## 索引

### 作用

* 用数据结构提高数据库的访问速度

### 优点

* 加快数据查找的速度
* 对排序or分组的字段添加索引，可以加快排序和分组的速度
* 加快表与表之间的连接

### 缺点

* 建立需要占物理空间
* 将低增删改的效率，需要动态维护索引

### 索引的数据结构

* B+树
* hash表

### hash索引和b+索引的区别

* 哈希索引**不支持排序**，因为哈希表式无序的
* 哈希索引**不支持范围查找**
* 哈希表不**支持模糊查询**及多列索引的**最左前缀匹配**
* 因为存在**哈希冲突**，哈希索引性能不稳定

### B树和B+树的区别

* 数据存储方式
* 数据检索方式
* 范围查询效率
* 适用场景

### 为什么B+树比B树更适合实现数据库索引

* 高效的范围查询
  * B+树：叶子节点形成有序链表（效率高）
  * B树：非叶子节点存储数据，需要中序列遍历定位数据（效率低）
* 减少磁盘I/O
  * B+树：非叶子节点仅存索引键
  * B树：节点需存储键值和数据指针
* 查询效率稳定
  * B+树：？？？
  * B树：
* 适应磁盘特性
  * B+树：
  * B树：

### 分类

* 主键索引
* 唯一索引
* 组合索引
* 全文索引
* 普通索引

### 最左匹配原则

* 组合索引由左到右的匹配（不按顺序无法匹配）
* 遇到范围查询停止匹配

### 聚集索引

* 双向链表结构的索引，逻辑上连续，排序与范围的查找速度快
* innoDB主键默认使用
* innoDB没指定主键时，会选择第一个不允许为NULL的唯一索引
* innoDB既没有指定主键，也没有合适的索引，会内部生成一个隐藏的主键作为聚集索引

### 覆盖索引

* 所有查询的字段(包括select)是索引的一部分
* 优点无需回表

### 索引设计原则

* 经常查询的字段
* 经常需要排序、分组和联合操作的字段
* 区分度高
* 避免用大字段
* 长字符串，可以指定一个较短的前缀（短索引）x
* 频繁增删改的不要建立
* 利用最左前缀原则

### 索引什么时候会失效

* 不符合最左前缀原则
* 以%开头的like查询
* 查询条件中列类型没使用引号，发生隐式转换
* 判断为不等于时
* 对索引列进行运算
* 查询条件or时

### 前缀索引

### 索引下推

* 5.6+支持
* 在回表前进行过滤

## 存储引擎

### 常见类型

* MyISAM
* InnoDB
* MEMORY
* ARCHIVE

### MyISAM和InnoDB的区别

* 存储结构的区别
* 存储空间的区别
* 可移植性、备份及恢复
* 是否支持行级锁
* 是否支持事务和奔溃后的安全恢复
* 是否支持外键
* 是否支持MVCC
* 是否支持聚集索引
* 全文索引
* 表主键
* 表的行数

## 有什么锁

* 锁粒度分类
  * 行级锁
  * 表级锁
  * 页级锁
* 锁级别分类
  * 共享锁 - 读锁
  * 排他锁 - 写锁
  * 意向锁 - 表级锁

  ## MVCC实现原理

  * 依赖**版本链**
    * DB_TRX_ID: 当前事务id
    * DB_ROLL_PTR: 回滚指针
    * DB_ROW_ID: 主键

## 快照读和当前读

## 共享锁和排他锁

## 日志

### bin log

* 数据库级别

### redo log

* InnoDB引擎级别

### undo log

* 修改时记录，用于数据回撤

### bin log 和 redo log 有什么区别？

* bin log
  * 记录所有日志记录
  * 事务提交前写入到磁盘，一个事务只写一次
  * 属于逻辑日志，记录SQL的原始逻辑
* redo log
  * 只记录innoDB的事务日志
  * 不断的写入磁盘
  * 属于物理日志，记录某个数据页上做了什么修改

## mysql 架构

* Server层
  * \[基本组件\] 连接器、查询缓存(8.0+移除)、分析器、优化器、执行器
  * \[其他组件\] 存储过程、触发器、视图、函数、binglog日志模块
* 存储引擎
  * 主要负责数据的存储和读取

## 分库分表

### 垂直划分

* 优点
  * 数据页可以放更多记录
* 缺点
  * 主键冗余，需要管理
  * 会引发join操作
  * 依然存在表单数据量过大的问题

### 水平划分

* 优点
  * 结构相同，程序改动较少
* 缺点
  * 分片事务一致性难以解决
  * 跨节点join性能差，逻辑复杂
  * 分片在扩容时需要迁移

## 什么是分区表

* 将一张表分为多个区块，都是独立的逻辑表，底层由多个物理子表组成。

## 分区表类型

* range - 范围分区
* list - 枚举值分区
* hash - 哈希分区

## 分区的问题

* 打开和锁住所有底层表的成本可能很高。
* 维护成本可能很高
* 所有的分区必须使用相同的存储引擎

## 查询语句的执行流程

1. 权限校验
2. 查询缓存
3. 分析器
4. 优化器
5. 权限校验
6. 执行器
7. 引擎

## 更新语句执行过程

* 分析器
* 权限校验
* 执行器
* 引擎
* redo log
* prepare

## exist和in的区别？

* exist
  * 子查询的表比较大的时候
  * 有效减少总的循环次数来提升速度
* in
  * 外查询的表比较大的时候
  * 有效减少对外查询表循环遍历来提升速度

## int(10)和char(10)的区别

* int(10)表示显示数据的长度
* char(10)表示的是存储数据的长度

## truncate、delete和drop区别

* 相同点
  * 功能相同，删除数据
  * drop、truncate都是DDL语句，执行后会自动提交
* 不同点
  * truncate 和 delete只删除数据不删除表的结构
  * drop将删除表的结构被依赖的约束、触发器、索引
  * 执行速度：drop > truncate > delete

## having 和 where 的区别

* 作用对象: where子句作用于表和视图， having作用于组
* 作用时间：where在分组前进行过滤，having分组后进行过滤

## 什么是 mysql 主从同步

* 将主服务器(master)的数据**异步**的复制到其余的从服务器(slave)

## 为什么要做主从同步?

* 读写分离，使数据库能支撑更大的并发
* 提高主服务器性能，主服务器生成实时数据，从服务器分析这些数据
* 数据备份，保证数据安全

## 乐观锁和悲观锁

* 悲观锁
  * 假设会发生冲突，事务提交后才释放锁
  * 使用数据库中的锁机制实现
* 乐观锁
  * 假设不会发生冲突，提交操作时才检查是否修改过
  * 一般使用版本号机制或CAS算法实现

## processlist

* 作用: 查看当前当前Mysql是否有压力、是否有慢SQL
* 参数:
  * id: 线程ID，可以用 kill id 杀死某个线程
  * db: 数据库名称
  * user: 数据库用户
  * host: 数据库实例的IP
  * command: 当前执行的命令
  * time: 消耗时间
  * state: 执行状态
    · Sleep: 线程在等待客户端发生新的请求
    · Locked: 线程在等待锁
    · Sending data: 正在处理Select查询的记录，同时把结果发送给客户端
    · Kill：正在执行kill语句，杀死指定线程
    · Connect：一个从节点连上了主节点
    · Quit：线程正在退出
    · Sorting for group：正在为GROUP BY 做排序
    · Sorting for order：正在为ORDER BY 做排序
  * info：正在执行的SQL语句

## MySQL 查询*limit 1000,10* 和 *limit 10* 速度一样快吗？

* 可以看作 *limit offset size* 和 *limit 0 size* 的区别，主要点：offset是否为0
* innodb的索引对于offset 会先取出数据再抛弃。
* *limit 10* 比 *limit 1000,10* 更快

## 深分页怎么优化

* 子查询select id ，再获取需要的id的数据，减少引擎层的数据拷贝
* 改为 where > offset

## 高度为3的B+树，可以存放多少数据

* innoDB存储引擎最小存储单元 - 页(page)
* page 默认大小：16384B = 16KB
* 非叶子节点：key(8字节) + 指针(6字节)，非叶子节点一页(16k)可以存放1170个索引指针
* 假设叶子节点一行数据1k，一页(16k)可以存储16条数据
* 高度3的B+树可以存放：1170*1170*16 条数据，约等于两千多万
