# Redis

## 致谢

[参考1](https://topjavaer.cn/redis/redis.html)

## 优点

* 基于内存操作，速度快
* 支持持久化
* 支持事务
* 支持主从复制
* 单线程模式，6.0+多线程处理网络数据的读写和协议解析

## 缺点

* 对结构化查询的支持差
* 数据库容量收到物理内存的限制，不适合海量数据的高性能读写。
* 较难支持在线扩容，集群容量达到上限时在线扩容会变得很复杂

## 快的原因

* 基于内存
* IO多路复用
* 高效的数据结构

## Redis为什么主要用做缓存

* \[事物处理\] 无法做复杂的事物处理
* \[数据持久化\] 数据存储在内存，服务器奔溃或者断电时数据可能丢失，其本身的持久化机制也有限制
* \[数据结构\] 支持简单的数据结构
* \[数据安全\] 没有用户认证，访问控制之类的安全机制

## 线程模式

* 基于Reactor模式开发了网络事件处理器 - 文件时间处理器
  * 组成1: 多个套接字
  * 组成2: IO多路复用程序
  * 组成3: 文件事件分派器
  * 组成4: 事件处理器

## 应用场景

* 缓存热点数据
* 计数器
* 分布式会话
* 分布式锁
* 简单的消息队列
* 限速器
* 社交网络
* 排行榜

## Memcached和Redis 的区别

* 数据结构
  * MemCached: 单一
  * Redis: 支持多种数据类型
* 数据持久化
  * MemCached: 不支持
  * Redis: 支持
* 集群能力
  * MemCached: 无原生，依靠客户端实现
  * Redis: 提供主从同步机制和cluster集群部署能力
* 速度
  * MemCached: 不慢
  * Redis: 更快
* 线程
  * MemCached: 多线程的非堵塞IO模型
  * Redis: 单线程，6.0+多线程处理网络数据的读写和协议解析
* value值大小
  * MemCached: 1mb
  * Redis: 512M

## 数据类型

* 基本
  * String
  * Hash
  * Set
  * List
  * SortedSet
* 特殊
  * Bitmap
  * Hyperloglog
  * Geospatial

## SortedSet和List异同点

* 相同点
  * 都是有序的
  * 都可以获得某个范围内的元素
* 不同点
  * 列表基于链表实现，获取两端元素速度快，访问中间元素慢
  * 有序集合基于散列标和跳跃表实现，访问中间元素时间复杂度OlogN
  * 列表不能简单的调整某个元素的位置，有序列表可以
  * 有序集合更耗内存

## Redis 内存用完了会怎样？

* 写命令会返回错误信息，读命令正常
* 可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容

## Redis如何做内存优化

* 利用好集合类型数据特性
* 对很多小k-V尽可能使用散列表

## Redis存在线程安全问题吗？

* 服务端安全
* 客户端在多客户端并发访问同一服务端是可能破坏原子性

## keys命令存在的问题

* keys指令会导致线程堵塞一段时间
* 可以用scan替代

## Redis事务

### 生命周期

* MULTI - 开启
* 操作的命令会插入一个队列中
* EXEC - 提交事务

### WAtCH命令

* 监控一个键，当被修改之后，后续的事务不会执行，执行exec之后会自动取消监控

### redis事务支持隔离吗？

* 事务带有隔离性

### redis事务保证原子性吗？

* 单条命令是原子性执行
* 事务不保证原子性

### redis事务支持回滚吗？

* 没有回滚
* 任意命令执行失败时，其余命令仍然执行

## 持久性机制

* RDB\[默认\] - 将内存中的数据写入磁盘中
* AOF\[主流\] - 以独立日志的方式记录每次写命令，解决数据持久化的实时性

## RDB和AOF如何选择

* 一般同时使用
* 同时开启时，Redis优先选择AOF

## Redis部署方案

### 种类

* 单机版
* 主从模式
* 哨兵模式
* Redis cluster(分片，3.0+)

### 单机版

* 能承载的QPS大概在上万到几万之间

### 主从架构

* 支撑高并发
* 一主多从，主写从读
* 原理
  1. 启动一个从节点时，会发送一个 *PSYNC*命令 给主节点
  2. 如果是初次连接，触发一次全量复制，主节点启动一个后台线程，生成一份PDB快照文件
  3. 主节点同时缓存客户端新收到的写命令（复制积压缓冲区），RDB生成完后，主节点会将RDB发送给从节点
  4. 从节点将RDB写入本地磁盘，再从本地磁盘加载到内存中
  5. 主节点将缓存的写命令发送到从节点同步
  6. 如果主从之间断线重连，会根据情况选择部分同步或者全量同步

### 哨兵Sentinel

* 自动切换主从节点，解决不能自动故障转移，达不到高可用的问题
* 工作原理
  1. 每个Sentinel以**1次/s**的频率向它所知道的Master，Slave以及其他Sentinel实例发送一个ping命令
  2. 如果一个实例距离最后一次有效回复ping命令的时间超过了指定值，则这个实例会被Sentinel标记为主观下线
  3. 如果一个Master被标记为主观下线，则正在监视这个Master的所有Sentinel要以每秒一次的频率确认Master是否真正进入主管下线状态
  4. 当有足够数量的Sentinel(>=配置文件指定值)在指定时间范围内确认Master的确进去主观下线，则标记Master为客观下线，反之，Master的客观下线状态会被解除，若Master重新向Sentinel的ping命令返回有效值，Master的主观下线状态就会被移除
  5. 哨兵节点会选举出哨兵leader，复制故障转移工作
  6. 哨兵leader会推选出某个表现良好的从节点成为新的主节点，然后通知其它从节点更新主节点信息

### Redis cluster

* 实现分布式存储，每个节点存储不同的内容；解决主节点的写能力，容量受限于单机配置的问题
* 最小配置：6个节点+(3主3从)
  * 主节点提供读写，
  * 从节点作为备用节点，只用于故障转移
* 采用虚拟槽分区，所有的键根据哈希函数映射到0～16383(二进制14个1)个整数槽内
* 工作原理
  1. 通过哈希方式，将数据分片，每个节点均分存储在一定哈希槽区间的数据，默认分配16384个槽位。
  2. 每份数据分片会存储在多个互为主从的多节点上
  3. 数据写入先写